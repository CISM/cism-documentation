
\section{Velocity solver}
\label{sc:glissade-velocity}

Glissade computes the ice velocity by solving an appropriate
approximation of the Stokes equations, given the 2D surface elevation and thickness fields and
the 3D temperature field.
Section \ref{sc:glissade-blatter-pattyn} describes assembly and solution of the matrix problem for the 
3D first-order Blatter-Pattyn approximation.  
Section \ref{sc:glissade-other-approx} discusses simpler approximations, including the SIA and SSA.

\subsection{Blatter-Pattyn approximation}
\label{sc:glissade-blatter-pattyn}

The basic equations of the Blatter-Pattyn approximation in Cartesian coordinates, repeated from 
Section \ref{sc:higher-order-mom}, are 

\begin{equation}
  \label{gliss.eq.stress_balance}
  \begin{split}
    x: \quad \frac{\partial }{\partial x}\left( 4 \eta \frac{\partial u}{\partial x} +  2 \eta \frac{\partial v}{\partial y} \right) + \frac{\partial }{\partial y}\left[ \eta \left( \frac{\partial u}{\partial y} + \frac{\partial v}{\partial x} \right) \right]+\frac{\partial }{\partial z}\left( \eta \frac{\partial u}{\partial z} \right) = \rho g\frac{\partial s}{\partial x}, \\
    y: \quad \frac{\partial }{\partial y}\left( 4 \eta \frac{\partial v}{\partial y} +  2 \eta \frac{\partial u}{\partial x} \right) + \frac{\partial }{\partial x}\left[ \eta \left( \frac{\partial u}{\partial y} + \frac{\partial v}{\partial x} \right) \right]+\frac{\partial }{\partial z}\left( \eta \frac{\partial v}{\partial z} \right) = \rho g\frac{\partial s}{\partial y},  \\
  \end{split}
\end{equation}

\noindent
where $u$ and $v$ are the components of horizontal velocity, $\eta$ is the effective viscosity, $s$ is the ice surface elevation,
$\rho$ is the density of ice (assumed constant), and $g$ is gravitational acceleration.  

As in Glide, the equations are discretized on a structured, rectangular horizontal mesh
of dimension $(nx,ny)$, together with a staggered mesh of dimension $(nx-1,ny-1)$.  The rectangles on the unstaggered mesh
are called \textit{cells}, and the corners of each cell (where four rectangles meet) are called \textit{vertices}.
The vertical \textit{levels} of the mesh are based on a terrain-following sigma coordinate system; 
we define $\sigma = (s-z)/H$, where $H$ is the ice thickness. Thus $\sigma = 0$ at the top surface and $\sigma = 1$ at the bed. 
There are $nz$ levels in the vertical direction, with $nz-1$ \textit{layers} between these levels.
An \textit{element} is the region associated with a particular cell and layer; there are
$(nx)(ny)(nz-1)$ elements on the mesh.  A \textit{node} is a point where eight elements intersect (or where four elements
intersect at the upper or lower surface). There are $(nx-1)(ny-1)(nz)$ nodes on the mesh.

Scalar 2D fields such as ice thickness $H$ and surface elevation $s$ are defined for each cell.
Scalar 3D fields such as ice temperature $T$ lie at the center of each element (i.e., at the midpoint of each layer
associated with  each cell). Gradients of 2D scalar fields (e.g., the surface slope $\nabla s$) are defined at vertices.
The velocity components $u$ and $v$ live at nodes.

An \textit{active cell} is a cell whose ice thickness exceeds a minimum threshold.  Each active cell is associated with
a column of $nz-1$ active elements.  An \textit{active vertex} is any vertex of an active cell.  Each active vertex is
associated with $nz$ active nodes, including nodes at the surface and bed.

The effective viscosity is defined in each active element by

\begin{equation}
  \label{gliss.eq.effective_viscosity}
  \eta \equiv \frac{1}{2} A^{\frac{-1}{n}} \dot{\varepsilon }_{e}^{\frac{1-n}{n}},
\end{equation}

\noindent
where $A$ is the temperature-dependent rate factor in Glen's flow law, and $\dot{\varepsilon }_{e}$ is the effective strain rate,
given in the Blatter-Pattyn approximation by 

\begin{equation}
  \label{gliss.eq.effective_strain_rate}
        {{\dot{\varepsilon }}^{2}}_{e}={{\dot{\varepsilon }}^{2}}_{xx}+{{\dot{\varepsilon }}^{2}}_{yy}+{{\dot{\varepsilon }}_{xx}}{{\dot{\varepsilon }}_{yy}}+{{\dot{\varepsilon }}^{2}}_{xy}+{{\dot{\varepsilon }}^{2}}_{xz}+{{\dot{\varepsilon }}^{2}}_{yz},
\end{equation}

\noindent
where

\begin{equation}
  \dot{\varepsilon }_{ij} = \frac{1}{2}\left( \frac{\partial u_{i}}{\partial x_{j}} + \frac{\partial u_{j}}{\partial x_{i}} \right).
\end{equation}

\noindent

Given $T$, $s$, $H$, and an initial guess for $u$ and $v$, the problem is to solve Eq. \eqref{gliss.eq.stress_balance}
for $u$ and $v$ at each active node.  (At inactive nodes we set $u=v=0$.)  This problem can be written in the form

\begin{equation}
  \mathbf{A} \mathbf{x} = \mathbf{b},
\end{equation}

\noindent
or more fully,

\begin{equation}
  \label{gliss.eq.matrix}
  \begin{matrix}
    \left[ \begin{matrix}
        \mathbf{A}_{\mathbf{uu}} & \mathbf{A}_{\mathbf{uv}}  \\
        \mathbf{A}_{\mathbf{vu}} & \mathbf{A}_{\mathbf{vv}}  \\
      \end{matrix} \right]\left[ \begin{matrix}
        \mathbf{u}  \\
        \mathbf{v}  \\
      \end{matrix} \right]=\left[ \begin{matrix}
        \mathbf{b}_{\mathbf{u}}  \\
        \mathbf{b}_{\mathbf{v}}  \\
      \end{matrix} \right]. \\ 
    \\ 
%    \mathbf{A}_{\mathbf{uu}}\mathbf{u} + \mathbf{A}_{\mathbf{uv}}\mathbf{v} =\mathbf{b}_{\mathbf{u}},
%    \quad \quad \mathbf{A}_{\mathbf{vu}}\mathbf{u} + \mathbf{A}_{\mathbf{vv}}\mathbf{v} =\mathbf{b}_{\mathbf{v}}. \\ 
  \end{matrix}
\end{equation}

\noindent
Eq. \eqref{gliss.eq.matrix} shows the four parts of the global matrix $\mathbf{A}$,
with the solution and right-hand-side vectors separated into $u$ and $v$ components.
In Glissade, $\mathbf{A}$ is always symmetric and positive-definite.

Since $\mathbf{A}$ depends (through $\eta$) on $u$ and $v$, the problem is nonlinear and must be solved iteratively.
For each nonlinear iteration, Glissade computes $\eta$ based on the
current guess for the velocity field and then solves a linear problem of the form \eqref{gliss.eq.matrix}.
Then $\eta$ is updated and the process is repeated until the solution converges to within a given tolerance.
This procedure is known as Picard iteration.

The following sections describe how the matrix equations are assembled and solved. 

\subsubsection{Assembly}

The coupled PDEs \eqref{gliss.eq.stress_balance} are discretized using the finite-element method.
Here we give a detailed but non-rigorous description of the method as applied to the Blatter-Pattyn
approximation on the CISM mesh.
We refer the reader to standard texts (one or two references here) for a full discussion of finite elements.

The PDEs, with appropriate boundary conditions, are converted to a system of algebraic equations
by dividing the full domain into subdomains, or elements, representing the solution on each element,
and integrating over elements. On the CISM mesh, the elements are hexahedra (rectangles
in map view), each of which has eight nodes shared with its neighbors.
The solution is approximated as a sum over basis functions $\varphi$. 
Each active node is associated with a basis function whose value is $\varphi = 1$ at that node,
with $\varphi = 0$ at all other nodes. The solution at a point
within an element can be represented as a sum of basis functions (evaluated at that point)
multiplied by nodal values:

\begin{equation}
\label{gliss.eq.velo_expansion}  
   u(x,y,z) = \sum\limits_{n}{{{\varphi }_{n}(x,y,z)}{{u}_{n}}}, \quad 
   v(x,y,z) = \sum\limits_{n}{{{\varphi }_{n}(x,y,z)}{{v}_{n}}},  \\
\end{equation}

\noindent
where the sum is over the nodes of the element, $u_n$ and $v_n$ are nodal
values of the solution, and $\varphi_n$ varies smoothly between 0 and 1 within the element.
The fact that $\varphi = 0$ except in a small region ensures that the sum includes only
as many terms as there are nodes per element.

Glissade uses standard finite-element techniques to represent the PDE on each element and assemble
the element equations into a global set of algebraic equations of the form \eqref{gliss.eq.matrix}.
The scheme is formally equivalent to that described by \citet{Perego2012} (henceforth PGB).
Note that \eqref{gliss.eq.stress_balance} can be written as

\begin{equation}
  \label{gliss.eq.Perego12}
  \begin{split}
    -\nabla \cdot (2\eta {{{\dot{\varepsilon }}}_{1}}) = -\rho g\frac{\partial s}{\partial x}, \\
    -\nabla \cdot (2\eta {{{\dot{\varepsilon }}}_{2}}) = -\rho g\frac{\partial s}{\partial y}, \\
  \end{split}
\end{equation}

\noindent
where

\begin{equation}
  \label{gliss.eq.Perego13}
  {{{\dot{\varepsilon }}}_{1}}=\left[ \begin{matrix}
      2{{{\dot{\varepsilon }}}_{xx}}+{{{\dot{\varepsilon }}}_{yy}} \\ 
      {{{\dot{\varepsilon }}}_{xy}} \\ 
      {{{\dot{\varepsilon }}}_{xz}} \\ 
    \end{matrix} \right], \quad
  {{{\dot{\varepsilon }}}_{2}}=\left[ \begin{matrix}
      {{{\dot{\varepsilon }}}_{xy}} \\ 
      {{{\dot{\varepsilon }}}_{xx}}+2{{{\dot{\varepsilon }}}_{yy}} \\ 
      {{{\dot{\varepsilon }}}_{yz}} \\ 
    \end{matrix} \right].  \\
\end{equation}

\noindent
(These are Eqs. 12 and 13 in PGB.)  We rewrite the equations in \textit{weak form} (see PGB Eq. 15), which
is obtained by multiplying \eqref{gliss.eq.Perego12} by the basis functions and integrating over the domain, using 
integration by parts to eliminate the second derivative:

\begin{equation}
  \label{gliss.eq.weak_form}
  \begin{split}
    x: \quad \int\limits_{\Omega } {2\eta {{{\dot{\varepsilon }}}_{1}}(u,v)\cdot \nabla {{\varphi }_{1}} \text{ d}\Omega }
      + \int\limits_{{\Gamma }_{B}} {\beta u{{\varphi }_{1}} \text{ d}\Gamma} 
      + \int\limits_{{\Gamma }_{L}} {p n_1 {{\varphi }_{1}} \text{ d}\Gamma}
      + \int\limits_{\Omega } {\rho g\frac{\partial s}{\partial x}{{\varphi }_{1}} \text{ d}\Omega}
      = \text{0},  \\
    y: \quad \int\limits_{\Omega } {2\eta {{{\dot{\varepsilon }}}_{2}}(u,v)\cdot \nabla {{\varphi }_{2}} \text{ d}\Omega }
      + \int\limits_{{\Gamma }_{B}} {\beta u{{\varphi }_{2}} \text{ d}\Gamma} 
      + \int\limits_{{\Gamma }_{L}} {p n_2 {{\varphi }_{2}} \text{ d}\Gamma}
      + \int\limits_{\Omega } {\rho g\frac{\partial s}{\partial y}{{\varphi }_{2}} \text{ d}\Omega}
      = \text{0},  \\
  \end{split}
\end{equation}

\noindent
where $\Omega$ represents the domain volume, $\Gamma_{B}$ denotes the lower boundary, $\Gamma_{L}$ denotes the lateral
boundary (e.g., the calving front of an ice shelf), $\beta$ is a basal traction parameter, $p$ is the pressure at the 
lateral boundary, and $n_1$ and $n_2$ are components of the normal to $\Gamma$.
These equations can also be obtained from a variational principle as described by \citet{DUKOWICZ:2010wb}.

The four terms of \eqref{gliss.eq.weak_form} describe internal ice streses, basal friction, lateral pressure,
and the gravitational driving force, respectively.  Next we describe how these terms are summed over elements
and assembled into the global matrix $\mathbf{A}$ and right-hand side vector $\mathbf{b}$.

We start with the internal stress term, which is the most complex.
We can rewrite the first term on the left-hand side of \eqref{gliss.eq.weak_form} in terms of velocity components:

\begin{equation}
  \label{gliss.eq.weak_form_velo}
  \begin{aligned}
    & x: \int\limits_{\Omega }{2\eta \left[ \begin{matrix}
          2\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y} & \frac{1}{2}\left( \frac{\partial u}{\partial y}+\frac{\partial v}{\partial x} \right) & \frac{1}{2}\frac{\partial u}{\partial z}  \\
\end{matrix} \right]}\left\{ \begin{matrix}
      \frac{\partial \varphi }{\partial x}  \\[6pt]
      \frac{\partial \varphi }{\partial y}  \\[6pt]
      \frac{\partial \varphi }{\partial z}  \\
    \end{matrix} \right\},  \\
    & y: \int\limits_{\Omega }{2\eta \left[ \begin{matrix}
          \frac{1}{2}\left( \frac{\partial u}{\partial y}+\frac{\partial v}{\partial x} \right) & 2\frac{\partial v}{\partial y}+\frac{\partial u}{\partial x} & \frac{1}{2}\frac{\partial v}{\partial z}  \\
        \end{matrix} \right]}\left\{ \begin{matrix}
      \frac{\partial \varphi }{\partial x}  \\[6pt]
      \frac{\partial \varphi }{\partial y}  \\[6pt]
      \frac{\partial \varphi }{\partial z}  \\
    \end{matrix} \right\},  \\
  \end{aligned}
\end{equation}

\noindent
where brackets are used for row vectors and braces for column vectors.
Glissade evaluates \eqref{gliss.eq.weak_form_velo} for each active element.  Recall that hexahedral elements have eight nodes,
with $u$ and $v$ to be determined at each active node.
Inserting the velocity expressions \eqref{gliss.eq.velo_expansion} in \eqref{gliss.eq.weak_form_velo}, we obtain

\begin{equation}
  \label{gliss.eq.element_matrix}
  \begin{split}
    x: \int\limits_{\Omega }{2\eta \left( \frac{\partial {{\varphi }_{i}}}{\partial x}\left( 2\left[ \frac{\partial {{\varphi }_{j}}}{\partial x} \right]\left\{ {{u}_{j}} \right\}+\left[ \frac{\partial {{\varphi }_{j}}}{\partial y} \right]\left\{ {{v}_{j}} \right\} \right)+\frac{\partial {{\varphi }_{i}}}{\partial y}\left( \frac{1}{2}\left[ \frac{\partial {{\varphi }_{j}}}{\partial y} \right]\left\{ {{u}_{j}} \right\}+\frac{1}{2}\left[ \frac{\partial {{\varphi }_{j}}}{\partial x} \right]\left\{ {{v}_{j}} \right\} \right)+\frac{\partial {{\varphi }_{i}}}{\partial z}\left( \frac{1}{2}\left[ \frac{\partial {{\varphi }_{j}}}{\partial z} \right]\left\{ {{u}_{j}} \right\} \right) \right)},  \\
    y: \int\limits_{\Omega }{2\eta \left( \frac{\partial {{\varphi }_{i}}}{\partial y}\left( 2\left[ \frac{\partial {{\varphi }_{j}}}{\partial y} \right]\left\{ {{v}_{j}} \right\}+\left[ \frac{\partial {{\varphi }_{j}}}{\partial x} \right]\left\{ {{u}_{j}} \right\} \right)+\frac{\partial {{\varphi }_{i}}}{\partial x}\left( \frac{1}{2}\left[ \frac{\partial {{\varphi }_{j}}}{\partial x} \right]\left\{ {{v}_{j}} \right\}+\frac{1}{2}\left[ \frac{\partial {{\varphi }_{j}}}{\partial y} \right]\left\{ {{u}_{j}} \right\} \right)+\frac{\partial {{\varphi }_{i}}}{\partial z}\left( \frac{1}{2}\left[ \frac{\partial {{\varphi }_{j}}}{\partial z} \right]\left\{ {{v}_{j}} \right\} \right) \right)}.  \\
  \end{split}
\end{equation}

\noindent
Each row or column vector has eight terms, one for each node of the element.
The terms in \eqref{gliss.eq.element_matrix} can be computed to give the terms of a set of four $8\text{x}8$ element matrices.
Each row of an element matrix is associated with $u$ or $v$ at a given node.  The columns in that row contain terms
linking that node to $u$ or $v$ at the other nodes of the element (with the diagonal term linking the node to itself).  

In the $x$ component of \eqref{gliss.eq.element_matrix}, 
the terms in row $i$ that multiply $u_j$ are given by
 
\begin{equation}
  \label{gliss.eq.matrix_Kuu}
  \int\limits_{\Omega }{\eta \left( 4\frac{\partial {{\varphi }_{i}}}{\partial x}\frac{\partial {{\varphi }_{j}}}{\partial x}+\frac{\partial {{\varphi }_{i}}}{\partial y}\frac{\partial {{\varphi}_{j}}}{\partial y}+\frac{\partial {{\varphi }_{i}}}{\partial z}\frac{\partial {{\varphi }_{j}}}{\partial z} \right)}d\Omega
\end{equation}

\noindent
Letting $i$ and $j$ range from 1 to 8, \eqref{gliss.eq.matrix_Kuu} gives the 64 terms of the $8\text{x}8$ element matrix $K_{uu}$,
which links the $u$ value at each node to the $u$ values at all eight nodes.
Similarly, the 64 terms of element matrix $K_{uv}$, which links $u$ at a given node to $v$ at all eight nodes,
are given by

\begin{equation}
  \label{gliss.eq.matrix_Kuv}
  \int\limits_{\Omega }{\eta \left( 2\frac{\partial {{\varphi }_{i}}}{\partial x}\frac{\partial {{\varphi }_{j}}}{\partial y}+\frac{\partial {{\varphi }_{i}}}{\partial y}\frac{\partial {{\varphi }_{j}}}{\partial x} \right)}d\Omega
\end{equation}

Likewise, two $8\text{x}8$ matrices are associated with the $y$ component of \eqref{gliss.eq.element_matrix}.  
The terms of $K_{vu}$, which connects $v$ at a given node to $u$ at all nodes, are given by

\begin{equation}
  \label{gliss.eq.matrix_Kvu}
  \int\limits_{\Omega }{\eta \left( 2\frac{\partial {{\varphi }_{i}}}{\partial y}\frac{\partial {{\varphi }_{j}}}{\partial x}+\frac{\partial {{\varphi }_{i}}}{\partial x}\frac{\partial {{\varphi }_{j}}}{\partial y} \right)}d\Omega
\end{equation}

\noindent
Finally, the terms of $K_{vv}$, which links $v$ at a given node to $v$ at all nodes, are given by

\begin{equation}
  \label{gliss.eq.matrix_Kvv}
  \int\limits_{\Omega }{\eta \left( 4\frac{\partial {{\varphi }_{i}}}{\partial y}\frac{\partial {{\varphi }_{j}}}{\partial y}+\frac{\partial {{\varphi }_{i}}}{\partial x}\frac{\partial {{\varphi}_{j}}}{\partial x}+\frac{\partial {{\varphi }_{i}}}{\partial z}\frac{\partial {{\varphi }_{j}}}{\partial z} \right)}d\Omega
\end{equation}

Because of the symmetry of the underlying PDEs, $K_{uu}$ and $K_{vv}$ are symmetric,
and $K_{uv} = K_{vu}^{T}$.  Note that $K_{vv}$ can be obtained from $K_{uu}$, and
$K_{vu}$ from $K_{uv}$, simply by exchanging $x$ and $y$.  The terms
containing $z$ (i.e., the vertical shear stresses associated with the shallow-ice approximation)
appear only in $K_{uu}$ and $K_{vv}$.  The terms containing $x$ and $y$ (i.e.,
the membrane stresses) appear in all four element matrices.

Eqs. \eqref{gliss.eq.matrix_Kuu}--\eqref{gliss.eq.matrix_Kvv} lie at the heart of the code 
(in subroutine \textit{compute\_element\_matrix} of module \textit{glissade\_velo\_higher.F90}).
Together with the expressions for the effective viscosity $\eta$ (discussed below),
these expressions contain the physical contents of the Blatter-Pattyn approximation. 

In the weak form of the equations, each of the 64 coefficients in each
element matrix must be integrated over the element.  (Since $\varphi$ varies over the element,
the integrands in \eqref{gliss.eq.matrix_Kuu}--\eqref{gliss.eq.matrix_Kvv} 
have a different value at each point.)  
This is done for a given element by evaluating the integrand at each of 
eight \textit{quadrature points} and summing over quadrature points.
We first have to specify the form of the basis functions, then transform the basis functions to
the geometry of the element (which is irregular in the vertical because of the sigma
coordinate) and evaluate the basis function derivatives at the quadrature points.

Glissade uses trilinear basis functions defined on a reference cube.  
This cube is centered at the origin $(0,0,0)$ in local reference coordinates 
$(\hat{x}, \hat{y}, \hat{z}$). 
The eight nodes are located at $(\hat{x}, \hat{y}, \hat{z}) = (\pm 1, \pm 1, \pm 1)$.
By convention, nodes 1--4 are the nodes of the lower face, proceeding counterclockwise
from the southwest corner $(\hat{x}, \hat{y}) = (-1, -1)$, and nodes 5--8 are the nodes
of the upper face, also moving counterclockwise from the southwest corner.
Thus we have

\begin{equation}
  \label{gliss.eq.basis_functions}
  \begin{matrix}
    {{\varphi }_{1}}=(1-\hat{x})(1-\hat{y})(1-\hat{z})/8,  \\[3pt]
    {{\varphi }_{2}}=(1+\hat{x})(1-\hat{y})(1-\hat{z})/8,  \\[3pt]
    {{\varphi }_{3}}=(1+\hat{x})(1+\hat{y})(1-\hat{z})/8,  \\[3pt]
    {{\varphi }_{4}}=(1-\hat{x})(1+\hat{y})(1-\hat{z})/8,  \\[3pt]
    {{\varphi }_{5}}=(1-\hat{x})(1-\hat{y})(1+\hat{z})/8,  \\[3pt]
    {{\varphi }_{6}}=(1+\hat{x})(1-\hat{y})(1+\hat{z})/8,  \\[3pt]
    {{\varphi }_{7}}=(1+\hat{x})(1+\hat{y})(1+\hat{z})/8,  \\[3pt]
    {{\varphi }_{8}}=(1-\hat{x})(1+\hat{y})(1+\hat{z})/8.  \\
  \end{matrix}
\end{equation} 

\noindent
For each $n$ we have $\varphi_n = 1$ at a single node, with $\varphi_n = 0$ at the other nodes.

The integrands in \eqref{gliss.eq.matrix_Kuu}--\eqref{gliss.eq.matrix_Kvv} 
are written in terms of real Cartesian coordinates $(x,y,z)$ rather than reference coordinates
$(\hat{x},\hat{y},\hat{z})$.
Spatial derivatives in real coordinates are related to derivatives in reference coordinates by

\begin{equation}
  \label{gliss.eq.real_to_reference}
  \scalebox{1.2}{
    $
  \left\{ \begin{matrix}
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}  \\[6pt]
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}  \\[6pt]
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{z}}  \\
  \end{matrix} \right\} = 
  \left[ \begin{matrix}
      \frac{\partial x}{\partial \hat{x}} & \frac{\partial y}{\partial \hat{x}} & \frac{\partial z}{\partial \hat{x}}  \\[6pt]
      \frac{\partial x}{\partial \hat{y}} & \frac{\partial y}{\partial \hat{y}} & \frac{\partial z}{\partial \hat{y}}  \\[6pt]
      \frac{\partial x}{\partial \hat{z}} & \frac{\partial y}{\partial \hat{z}} & \frac{\partial z}{\partial \hat{z}}  \\
    \end{matrix} \right]
  \left\{ \begin{matrix}
    \frac{\partial {{\varphi }_{n}}}{\partial x}  \\[6pt]
    \frac{\partial {{\varphi }_{n}}}{\partial y}  \\[6pt]
    \frac{\partial {{\varphi }_{n}}}{\partial z}  \\
  \end{matrix} \right\} =
   [J]\left\{ \begin{matrix}
     \frac{\partial {{\varphi }_{n}}}{\partial x}  \\[6pt]
     \frac{\partial {{\varphi }_{n}}}{\partial y}  \\[6pt]
     \frac{\partial {{\varphi }_{n}}}{\partial z}  \\
   \end{matrix} \right\},
   $
  }
\end{equation}

\noindent
where $[J]$ is the Jacobian of the transformation between coordinate systems.  
Given the finite-element expansion

\begin{equation}
   x = \sum\limits_{n}{{{\varphi }_{n}}{{x}_{n}}},
\end{equation}

\noindent
along with the spatial derivatives of $\varphi$ at $(\hat{x},\hat{y},\hat{z})$
(which are easily derived from \eqref{gliss.eq.basis_functions}),
we can compute $[J(\hat{x},\hat{y},\hat{z})]$ as

\begin{equation}
  \label{gliss.eq.Jacobian_eval}
  \scalebox{1.2}{
  $
        [J]=\left[ \begin{matrix}
            \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}{{x}_{n}}} & \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}{{y}_{n}}} & \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}{{z}_{n}}}  \\[6pt]
            \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}{{x}_{n}}} & \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}{{y}_{n}}} & \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}{{z}_{n}}}  \\[6pt]
            \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{z}}{{x}_{n}}} & \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{z}}{{y}_{n}}} & \sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{z}}{{z}_{n}}}  \\
          \end{matrix} \right].
        $
        }
\end{equation}

\noindent
We then invert \eqref{gliss.eq.real_to_reference} to obtain the 
basis function derivatives in terms of $(x,y,z)$:

\begin{equation}
  \label{gliss.eq.reference_to_real}
  \scalebox{1.2}{
    $
  \left\{ \begin{matrix}
     \frac{\partial {{\varphi }_{n}}}{\partial x}  \\[6pt]
     \frac{\partial {{\varphi }_{n}}}{\partial y}  \\[6pt]
     \frac{\partial {{\varphi }_{n}}}{\partial z}  \\
  \end{matrix} \right\} =
          [J^{-1}]  \left\{ \begin{matrix}
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}  \\[6pt]
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}  \\[6pt]
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{z}}  \\
  \end{matrix} \right\}. 
          $
          }
\end{equation}

\noindent
The left-hand side of \eqref{gliss.eq.reference_to_real} contains the spatial derivatives 
appearing in \eqref{gliss.eq.matrix_Kuu}--\eqref{gliss.eq.matrix_Kvv}.

Eqs. \eqref{gliss.eq.matrix_Kuu}--\eqref{gliss.eq.matrix_Kvv} also contain the viscosity $\eta$,
which is computed at each quadrature point.
In the Blatter-Pattyn approximation, $\eta$ is given by \eqref{gliss.eq.effective_viscosity};
it is a function of the flow factor $A$ and the effective strain rate defined by \eqref{gliss.eq.effective_strain_rate}.
We approximate $A$ by its value at the element center.
The (squared) effective strain rate, ${{\dot{\varepsilon }}^{2}}_{e}$, is evaluated at each quadrature point
by summing over strain-rate components.  The $x$ components are given by

\begin{equation}
  \label{gliss.eq.strain_rates}
  \frac{\partial u}{\partial x}=\sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial x}}{{u}_{n}}, \quad
  \frac{\partial v}{\partial x}=\sum\limits_{n=1}^{8}{\frac{\partial {{\varphi }_{n}}}{\partial x}}{{v}_{n}},
\end{equation}

\noindent
and similarly for the $y$ and $z$ components.  The nodal velocities in \eqref{gliss.eq.strain_rates}
are values from the previous iteration; otherwise the resulting system of equations would be nonlinear.

We now have the information needed to compute the integrands \eqref{gliss.eq.matrix_Kuu}--\eqref{gliss.eq.matrix_Kvv}
at quadrature points. To integrate over a hexahedron, we take a weighted sum of the values at each
of eight quadrature points.  These points are located at
reference coordinates $(\hat{x},\hat{y},\hat{z}) = (\pm 1/\sqrt{3}, \pm 1/\sqrt{3}, \pm 1\sqrt{3})$.
Thus, to evaluate an integral of the form

\begin{equation}
  \int\limits_{\Omega }{\eta \left( \frac{\partial {{\varphi }_{i}}}{\partial z}\frac{\partial {{\varphi }_{j}}}{\partial z} \right)}d\Omega
\end{equation}

\noindent
over element volume $\Omega$, we compute the sum over quadrature points

\begin{equation}
  \label{gliss.eq.sum_over_qp}
  \sum\limits_{p=1}^{8}{{{w}_{p}}{{\eta }_{p}}{{\left( \frac{\partial {{\varphi }_{i}}}{\partial z}\frac{\partial {{\varphi }_{j}}}{\partial z} \right)}_{p}}}|J_p|,
\end{equation}

\noindent
where $|J|$ is the determinant of the Jacobian \eqref{gliss.eq.Jacobian_eval}. For this choice of quadrature points,
each point has $w_p = 1$.

The terms of the element matrices $K_{uu}, K_{uv}, K_{vu}$ and $K_{vv}$
are then inserted into the corresponding global matrices $A_{uu}, A_{uv}, A_{vu}$ and $A_{vv}$.
This is mostly a matter of bookkeeping.
For example, the first row of $K_{uu}$ corresponds to a particular node of element $(k,i,j)$
(specifically, the node with indices $(k-1,i-1,j-1)$, given our convention for numbering nodes within elements).  
This row is mapped to a row of the global matrix $A_{uu}$, 
and each of the eight terms in this row is associated with a column of $A_{uu}$.  
Glissade determines the correct column
and adds the $K_{uu}$ term to the corresponding term in $A_{uu}$.  This process proceeds
until the code has looped over all the active elements and filled the global matrices.

If written in full, each global matrix would have as many rows and columns as there are active nodes.
These matrices, however, are sparse, with a maximum of 27 nonzero terms per row (corresponding to
a node and its 26 nearest neighbors in a 3D hexahedral lattice).
Glissade therefore assembles and stores global matrices of dimension $(27,nz,nx-1,ny-1)$.
The 27 terms of the first dimension are indexed such that each index has a geometric meaning.
For example, suppose we are labeling columns for the matrix row corresponding to node $(k,i,j)$. 
Then index 1 corresponds to the node with coordinates $(k-1,i-1,j-1)$, index 14 corresponds to the
node itself (i.e., the diagonal term of the row), and index 27 is associated with the node at $(k+1,i+1,j+1)$.
The global matrices can be reformatted as needed before being passed to a particular solver. 

The remaining assembly consists of evaluating the other terms in \eqref{gliss.eq.weak_form}
(i.e., the basal and lateral boundary conditions and the gravitational forcing) and implementing
Dirichlet boundary conditions, if applicable. We consider these in turn.

We begin with boundary conditions.  At the basal boundary we assume
a friction law of the form $\tau_x = -\beta u, \tau_y = -\beta v$.  The coefficient $\beta$ is defined
at each vertex and can vary spatially.  If $\beta$ depends on the velocity, as in some friction laws,
then it is calculated using the velocity from the previous iteration.

The basal boundary terms to be evaluated in \eqref{gliss.eq.weak_form} are

\begin{equation}
  \label{gliss.eq.basal_bc}
  \begin{split}
    x: \int\limits_{{\Gamma }_{B}} \beta u{{\varphi }_{1}} d\Gamma , \\
    y: \int\limits_{{\Gamma }_{B}} \beta v{{\varphi }_{2}} d\Gamma . \\
  \end{split}
\end{equation}

\noindent
The basal face of each cell is a rectangle. To integrate over a rectangle, we 
sum over terms at four quadrature points.  These points lie at $(\hat{x},\hat{y}) = (\pm 1/\sqrt{3}, \pm 1/\sqrt{3}$)
in a reference square with center $(0,0)$ and vertices $(\pm1,\pm1)$.
(This reference square is the 2D analog of the reference cube discussed above.)
We define four bilinear basis functions on the square (cf. \eqref{gliss.eq.basis_functions}):

\begin{equation}
  \label{gliss.eq.basis_functions_2d}
  \begin{matrix}
    {{\varphi }_{1}}=(1-\hat{x})(1-\hat{y})/4,  \\[3pt]
    {{\varphi }_{2}}=(1+\hat{x})(1-\hat{y})/4,  \\[3pt]
    {{\varphi }_{3}}=(1+\hat{x})(1+\hat{y})/4,  \\[3pt]
    {{\varphi }_{4}}=(1-\hat{x})(1+\hat{y})/4.
  \end{matrix}
\end{equation}

\noindent
Given these basis functions and their spatial derivatives, we can compute the Jacobian
for the transformation between the reference square and the rectangular cell face,
using the 2D versions of \eqref{gliss.eq.Jacobian_eval} and \eqref{gliss.eq.reference_to_real}:

\begin{equation}
  \label{gliss.eq.Jacobian_eval_2d}
  \scalebox{1.2}{
  $
        [J]=\left[ \begin{matrix}
            \sum\limits_{n=1}^{4}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}{{x}_{n}}} & \sum\limits_{n=1}^{4}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}{{y}_{n}}} \\[6pt]
            \sum\limits_{n=1}^{4}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}{{x}_{n}}} & \sum\limits_{n=1}^{4}{\frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}{{y}_{n}}} \\[6pt]
          \end{matrix} \right],
        $
        }
\end{equation}

\begin{equation}
  \label{gliss.eq.reference_to_real_2d}
  \scalebox{1.2}{
    $
  \left\{ \begin{matrix}
     \frac{\partial {{\varphi }_{n}}}{\partial x}  \\[6pt]
     \frac{\partial {{\varphi }_{n}}}{\partial y}  \\
  \end{matrix} \right\} =
          [J^{-1}]  \left\{ \begin{matrix}
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{x}}  \\[6pt]
    \frac{\partial {{\varphi }_{n}}}{\partial \hat{y}}  \\
  \end{matrix} \right\}. 
          $
          }
\end{equation}

The integrand at a quadrature point has the form
\begin{equation}
  \label{gliss.eq.beta_integrand}
  \beta \varphi_i \varphi_j,
\end{equation}

\noindent
where the second $\varphi$ term arises from the finite-element expansion of $u$ at a quadrature point:

\begin{equation}
  u = \sum\limits_{n=1}^{4} {u_n \varphi_n}.
\end{equation}

\noindent
We determine $\beta$ at quadrature points from the values at cell vertices:

\begin{equation}
  \beta = \sum\limits_{n=1}^{4} {\beta_n \varphi_n}.
\end{equation}

\noindent
The integral of \eqref{gliss.eq.beta_integrand} over a cell is then computed as a sum over quadrature points:

\begin{equation}
  \label{gliss.eq.sum_over_qp_beta}
  \sum\limits_{p=1}^{4} {w_p \beta_p (\varphi_i \varphi_j)_p |J_p|},
\end{equation}

\noindent
where $w_p = 1$ for each point.  This procedure generates a 4\text{x}4 matrix
describing the connections between each node and its neighbors in the cell.
%This is a 2D analog of the element matrices discussed above.  
Since the $x$ term in \eqref{gliss.eq.basal_bc} 
contains $u$ but not $v$, and the $y$ term contains
$v$ but not $u$, we form 2D matrices $K_{uu}$ and $K_{vv}$, but not $K_{uv}$ and $K_{vu}$.
Each term of $K_{uu}$ is then inserted into the global matrix $A_{uu}$, and
similarly for $K_{vv}$ and $A_{vv}$.


The lateral boundary terms in \eqref{gliss.eq.weak_form} are

\begin{equation}
  \label{gliss.eq.lateral_bc}
  \begin{split}
    x: \int\limits_{{\Gamma }_{L}} {p n_1 {{\varphi }_{1}} \text{ d}\Gamma}, \\
    y: \int\limits_{{\Gamma }_{L}} {p n_2 {{\varphi }_{2}} \text{ d}\Gamma}.
  \end{split}
\end{equation}

\noindent
Since these terms are independent of $u$ and $v$, they contribute to the load vectors
$\mathbf{b_u}$ and $\mathbf{b_v}$ on the right-hand side of \eqref{gliss.eq.matrix}.
They are integrated over the lateral faces of floating cells that border the ocean.
(Grounded cells are assumed to have no lateral forcing at the margin.)

The lateral faces bordering the ocean are quadrilaterals that can be mapped to a reference square.
As for the basal boundary terms, the integral over each face is found by 
summing over four quadrature points.
Basis functions are given by \eqref{gliss.eq.basis_functions_2d}, and
the Jacobian of the reference square is computed using \eqref{gliss.eq.Jacobian_eval_2d}.
We evaluate the ice thickness $H$ at each quadrature point using

\begin{equation}
  \label{gliss.eq.thickness_qp}
  H = \sum\limits_{n=1}^{4} {H_n \varphi_n},
\end{equation}

\noindent
where the $H_n$ are nodal values.
%(Each lateral face contains two pairs of nodes aligned in the vertical; aligned nodes
%have the same values for $H$ and $s$.) 
The integrands have the form $p_n \varphi$, where $p_n$ is the vertically averaged
net pressure normal to the ice edge.  
(We use the vertically averaged pressure to avoid issues with vertical shearing at the ice edge.)
The net pressure is equal to the pressure
directed outward from the ice toward the ocean by the weight of the ice, minus the (smaller)
pressure directed inward from the ocean to the ice by the hydrostatic water pressure.
The outward pressure is obtained by integrating $\rho_i g (s-z) dz$ from $s-H$ to $s$
and then dividing by $H$; it is given by 

\begin{equation}
  \label{gliss.eq.lateral_pout}
  p_{\text{out}} = \frac{\rho_i g H}{2},
\end{equation}

\noindent
using $H$ from \eqref{gliss.eq.thickness_qp}.
The inward pressure is found by integrating $(-\rho_w g z dz)$ from $s-H$ to 0
and then dividing by $H-s$; it is given by

\begin{equation}
  \label{gliss.eq.lateral_pin1}
  p_{\text{in}} = \frac{\rho_w g (s-H)^2}{2H}
\end{equation}

\noindent
Assuming hydrostatic balance, we have $s-H = (\rho_i/\rho_w)H$. Thus \eqref{gliss.eq.lateral_pin1} becomes

\begin{equation}
  \label{gliss.eq.lateral_pin2}
  p_{\text{in}} = \frac{\rho_i g H}{2} \frac{\rho_i}{\rho_w}
\end{equation}

\noindent
Combining \eqref{gliss.eq.lateral_pout} and \eqref{gliss.eq.lateral_pin2} gives

\begin{equation}
  \label{gliss.eq.lateral_pnet}
  p_{\text{net}} = \frac{\rho_i g H}{2} \left(1 - \frac{\rho_i}{\rho_w}\right),
\end{equation}

\noindent
directed from the ice to the ocean.  
The integral of the pressure terms over a lateral face is then found as a sum over quadrature points:

\begin{equation}
  \label{gliss.eq.sum_over_qp_lateral}
  \sum\limits_{p=1}^{4} {\pm w_p (p_\text{net})_p (\varphi_i)_p |J_p|},
\end{equation}

\noindent
where the sign depends on the orientation of the face.  The resulting pressure terms
are inserted into the load vector (either $\mathbf{b_u}$ or $\mathbf{b_v}$, depending on the orientation)
associated with each of the four nodes of the face.

Finally, the gravitational forcing terms in \eqref{gliss.eq.weak_form} are

\begin{equation}
  \label{gliss.eq.gravity_forcing}
  \begin{split}
    x: \int\limits_{\Omega } {\rho g\frac{\partial s}{\partial x}} {{\varphi }_{1}}\text{ d}\Omega, \\
    y: \int\limits_{\Omega } {\rho g\frac{\partial s}{\partial y}} {{\varphi }_{2}}\text{ d}\Omega. \\
  \end{split}
\end{equation}

\noindent
To compute these terms we evaluate $\frac{\partial s}{\partial x}$ and $\frac{\partial s}{\partial y}$
at each active vertex.  A standard centered approximation at vertex $(i,j)$ is

\begin{equation}
  \label{gliss.eq.dsdx_centered}
  \frac{\partial s}{\partial x}(i,j) = \frac{s(i+1,j+1)+s(i+1,j)-s(i,j+1)-s(i,j)}{2\Delta x}
\end{equation}

\noindent
(and similarly for $\frac{\partial s}{\partial y}$). This approximation works
well when the ice geometry is fixed but can cause problems when the geometry is evolving.
These problems arise because checkerboard noise in $s$ (which is common on structured meshes
with the velocity at cell vertices) is invisible to the momentum balance; 
it is canceled out by the centered averaging in \eqref{gliss.eq.dsdx_centered}.
Checkerboard noise can therefore persist and grow.  To damp this noise, Glissade uses an upstream average:

\begin{equation}
  \label{gliss.eq.dsdx_upstream}
  \frac{\partial s}{\partial x}(i,j) = \frac{1.5 (s(i+1,j+1) - s(i,j+1)) - 0.5 (s(i+1,j+2) - s(i,j+2))}{\Delta x}.
\end{equation}

\noindent
Here, ``upstream'' means in the direction of increasing surface elevation. Both \eqref{gliss.eq.dsdx_centered}
and \eqref{gliss.eq.dsdx_upstream} are second-order accurate.

The integrals in \eqref{gliss.eq.gravity_forcing} are over 3D elements.
Hence we map each hexahedral element to a reference cube as described above. 
Given $\frac{\partial s}{\partial x}$ at the nodes of a cell,
the surface slope terms at quadrature points are

\begin{equation}
  \frac{\partial s}{\partial x} = \sum\limits_{n=1}^{4}{{{\varphi }_{n}}}{{\left( \frac{\partial s}{\partial x} \right)}_{n}},
\end{equation}

\noindent
where the basis function $\varphi$ are given by \eqref{gliss.eq.basis_functions}
and the spatial derivatives are derived from \eqref{gliss.eq.Jacobian_eval} and \eqref{gliss.eq.reference_to_real}.
The integral of $\rho g \frac{\partial s}{\partial x} \varphi$
over an element is then evaluated as a sum over quadrature points:

\begin{equation}
  \label{gliss.eq.sum_over_qp_gravity}
  \sum\limits_{p=1}^{8} { w_p \rho g \left(\frac{\partial s}{\partial x}\right)_p (\varphi_i)_p |J_p|},
\end{equation}

\noindent
and similarly for the $\frac{\partial s}{\partial y}$ term.
Glissade inserts these terms into the load vectors $\mathbf{b_u}$ and $\mathbf{b_v}$
associated with each active node of the element.


Next the Dirichlet BCs...

\subsubsection{Solving the matrix equation}

\subsection{Other Stokes approximations}
\label{sc:glissade-other-approx}






